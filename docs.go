package wraperrors

/*
wraperrors provides a simple interface to work with wrap errors. A wrap error has two errors:
- A wrapper error
- A wrapped error

The wrapper error is suposed to be generated by a higher level part of the code and provide more general information,
whereas the wrapped error is supposed to have more specific details about the actual error.

You can create a new wrap error:

```go
wrappedErr := errors.New("unexpected character '/'")
wrapperErr := errors.New("bad request")
wrapErr := wraperrors.New(wrapperErr, wrappedErr)
```

The package also provides a SimpleError type which is useful to create wrap errors that will have the simple error as
the wrapper.

The main difference between wraperrors and standard wrap errors (`fmt.Errorf("something went wrong, %w", err1)`)
is that wraperrors allow to easily compare the wrapper error:

```go
const (
	BadRequestError = wraperrors.SimpleError("bad request error")
	ConnectionError = wraperrors.SimpleError("temporal error, try later")
	InternalError   = wraperrors.SimpleError("internal error")
)

func f() error {
	_, err := getSomethingFromTheInternet()
	if err == ConnectionTimeOut {
		return ConnectionError.Wrap(err)
	} else if err == UnexpectedCharacter || err == MissingArguments {
		return BadRequestError.Wrap(err)
	} else if err != nil {
		return InternalError.Wrap(err)
	}
	return nil
}

err := f()
if errors.Is(err, ConnectionError) {
	// retry after timeout
} else if errors.Is(err, BadRequestError) {
	// logic for bad request
} else {
	// logic for internal error
}
```
*/
